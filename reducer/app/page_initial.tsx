
// import WebGPUExample from '../components/compute_shader';

// export default function Home() {
//   return (
//     <div>
//       <WebGPUExample />
//     </div>
//   );
// }

// box to paste in json object & use as params instead of textboxes
// one box for RACY shader and the other for SAFE shader, label
// potential shader db functionality-- or paste in json
// run both with one button-- run one right after the other
// then compare results-- code in app/analyze_results.js
// textbox for compared results

// threads running -- each thread has a few memory locations (locs_per_thread)
// within those memry locations, some are safe (only accessed by that thread) and some are racy (can be accessed by other threads)
// if you have htose data races on one memory location can it affect safe memory locations

// data races are similar to race conditions (war, raw, etc) but are not dependent on the code-- they are inherent to programming language
// becasue hardware and compilers can do tricky optimizations

// register-pressure: limited registers, instead of keeping temp variables it'll spill those registers to memory
// see paper for example + more info
// in shaders,  we have so many variables to increase register pressure

// safe shader operates on safe memory locations
// racy = safe with more lines (b line = safe, c = 1 etc top two lines make it racy)

// reduction
// simple reduction
// cutting out lines and cutting out variables


// darton-yan code??


'use client';

import React, { useState } from "react";
import { run_shader } from "../components/run_shader"; // Adjust the path based on your directory structure

const ShaderRunner = () => {
  const [shader1, setShader1] = useState('');
  const [shader2, setShader2] = useState('');
  const [shader1Output, setShader1Output] = useState<string | null>(null);
  const [shader2Output, setShader2Output] = useState<string | null>(null);
  const [workgroupSize, setWorkgroupSize] = useState('256'); // Default value as string
  const [workgroups, setWorkgroups] = useState('1'); // Default value as string

  const shaderInfo = {
    workgroup_size: parseInt(workgroupSize) || 0, // Convert to number
    workgroups: parseInt(workgroups) || 0, // Convert to number
    locs_per_thread: 1,
    constant_locs: 0,
    uninit_vars: 1,
    race_val_strat: 'Even',
  };

  const handleRunShader = async (shader: string, setOutput: React.Dispatch<React.SetStateAction<string | null>>) => {
    try {
      const outputs = await run_shader(shader, shaderInfo);
      if (!outputs || outputs.length === 0) {
        setOutput('No outputs were generated by the shader.');
        return;
      }
      setOutput(outputs.map((arr) => Array.from(arr).join(', ')).join('\n\n'));
    } catch (error) {
      console.error('Error running shader:', error);
      setOutput('Error running shader');
    }
  };

  return (
    <div style={styles.container}>
      <h1 style={styles.title}>Shader Runner</h1>
      <div style={styles.mainRow}>
        {/* Configuration Inputs */}
        <div style={styles.configContainer}>
          <div style={styles.inputGroup}>
            <label style={styles.label} htmlFor="workgroups">Workgroups:</label>
            <textarea
              id="workgroups"
              style={styles.thinTextArea} // Thinner vertical height
              value={workgroups}
              onChange={(e) => setWorkgroups(e.target.value)}
              placeholder="Enter workgroups"
            />
          </div>
          <div style={styles.inputGroup}>
            <label style={styles.label} htmlFor="workgroupSize">Workgroup Size:</label>
            <textarea
              id="workgroupSize"
              style={styles.thinTextArea} // Thinner vertical height
              value={workgroupSize}
              onChange={(e) => setWorkgroupSize(e.target.value)}
              placeholder="Enter workgroup size"
            />
          </div>
        </div>

        {/* Shader Sections */}
        <div style={styles.shaderContainer}>
          <div style={styles.row}>
            {/* Shader 1 Section */}
            <div style={styles.column}>
              <h2 style={styles.subTitle}>Safe Shader</h2>
              <textarea
                style={styles.largeTextArea} // Longer shader input
                value={shader1}
                onChange={(e) => setShader1(e.target.value)}
                placeholder="Paste WGSL shader code here"
              />
              <button style={styles.greenButton} onClick={() => handleRunShader(shader1, setShader1Output)}>
                Run Safe Shader
              </button>
              <div style={styles.output}>
                <pre style={styles.code}>{shader1Output || 'Safe Shader Output will appear here...'}</pre>
              </div>
            </div>

            {/* Shader 2 Section */}
            <div style={styles.column}>
              <h2 style={styles.subTitle}>Racy Shader</h2>
              <textarea
                style={styles.largeTextArea} // Longer shader input
                value={shader2}
                onChange={(e) => setShader2(e.target.value)}
                placeholder="Paste WGSL shader code here"
              />
              <button style={styles.greenButton} onClick={() => handleRunShader(shader2, setShader2Output)}>
                Run Racy Shader
              </button>
              <div style={styles.output}>
                <pre style={styles.code}>{shader2Output || 'Racy Shader Output will appear here...'}</pre>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    minHeight: '100vh',
    padding: '20px',
    fontFamily: 'Arial, sans-serif',
    backgroundColor: '#fff',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  title: {
    fontSize: '36px',
    textAlign: 'center',
    color: '#000',
    marginBottom: '20px',
  },
  mainRow: {
    display: 'flex',
    width: '100%',
    justifyContent: 'flex-start',
    gap: '20px',
  },
  configContainer: {
    display: 'flex',
    flexDirection: 'column',
    gap: '15px',
    minWidth: '150px',
  },
  inputGroup: {
    display: 'flex',
    flexDirection: 'column',
  },
  label: {
    fontSize: '14px',
    marginBottom: '5px',
    color: '#555',
  },
  thinTextArea: {
    width: '100%', // Restored original width
    height: '37px', // Reduced vertical height
    borderRadius: '8px',
    border: 'none',
    padding: '10px',
    fontFamily: 'monospace',
    fontSize: '14px',
    backgroundColor: '#f0f0f0',
    color: '#333',
    resize: 'none',
  },
  shaderContainer: {
    flex: 1,
    display: 'flex',
    flexDirection: 'column',
    gap: '20px',
  },
  row: {
    display: 'flex',
    justifyContent: 'space-evenly',
    gap: '20px',
  },
  column: {
    flex: '1',
    maxWidth: '45%',
    display: 'flex',
    flexDirection: 'column',
    gap: '10px',
  },
  subTitle: {
    fontSize: '18px',
    color: '#000',
    marginBottom: '10px',
  },
  largeTextArea: {
    width: '100%', // Longer width for shader inputs
    height: '300px',
    borderRadius: '8px',
    border: 'none',
    padding: '10px',
    fontFamily: 'monospace',
    fontSize: '14px',
    backgroundColor: '#f0f0f0',
    color: '#333',
    resize: 'vertical',
  },
  greenButton: {
    marginTop: '10px',
    padding: '10px 20px',
    backgroundColor: '#28a745',
    color: '#fff',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '14px',
    transition: 'background-color 0.3s',
  },
  output: {
    marginTop: '10px',
    backgroundColor: '#f0f0f0',
    borderRadius: '8px',
    padding: '10px',
    overflow: 'auto',
    maxHeight: '200px',
  },
  code: {
    fontFamily: 'monospace',
    fontSize: '14px',
    whiteSpace: 'pre-wrap',
    wordBreak: 'break-word',
    color: '#333',
  },
};

export default ShaderRunner;


